# Gap Analysis — Codex Subagent

> Generated by Codex subagent for Phase 3A
> Date: 2026-02-12
> Sources: `docs/agent-flow.md` (ideal flow), `docs/existing-apis.md`, `docs/existing-contracts.md`, `docs/existing-state-machine.md`, `docs/existing-models.md`, and verified against source code (`server.py`, `models.py`, `services/job_service.py`, `services/agent_service.py`, `services/wallet_service.py`, `config.py`)

---

## Gap Table

### A. Publisher (Buyer) Agent Flow Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 1 | Register as Agent | `POST /agents` with `agent_id`, `name`, `wallet_address` | ✅ Implemented | Endpoint exists and works as described. Returns 201 on success, 409 if duplicate, 400 if invalid wallet format. | — |
| 2 | Get Deposit Info | `GET /platform/deposit-info` returning ops wallet, USDC contract, chain, min_amount, chain_connected | ✅ Implemented | Endpoint exists and returns all required fields. | — |
| 3 | Create Task | `POST /jobs` with title, description, rubric, price, buyer_id, artifact_type, expiry, max_submissions, max_retries, min_reputation | ✅ Implemented | Endpoint exists with all documented fields. Validates required fields, price >= MIN_TASK_AMOUNT, expiry as unix timestamp. | — |
| 4 | Deposit USDC On-Chain | Off-platform action (Base L2 USDC transfer) | ✅ N/A (off-platform) | This step is performed by the agent externally. Platform provides deposit-info endpoint for guidance. | — |
| 5 | Fund Task | `POST /jobs/<id>/fund` with buyer_id + tx_hash | ✅ Implemented | Endpoint exists. Verifies USDC transfer event, 12 confirmations, amount >= price. DEV_MODE bypass available. Transitions open -> funded. | — |
| 6 | Monitor Task Status (Polling) | `GET /jobs/<id>` returning status, participants, submission_count, winner_id | ⚠️ Partial | Endpoint exists and returns needed fields. **However**: (1) No webhook/SSE/push notification — agent must poll; (2) No `GET /jobs/<id>/submissions` filtering by status (e.g., only `judging` submissions); (3) Lazy expiry means expired jobs only transition on read — no proactive notification. | P1 |
| 7 | Publisher: View submissions and oracle feedback | `GET /jobs/<id>/submissions` returning oracle verdicts | ⚠️ Partial | Endpoint exists. **However**: oracle_steps are sanitized (only step name + pass/fail) — publisher cannot see detailed evaluation reasoning. This limits the publisher's ability to understand why submissions fail or pass. | P2 |
| 8 | Task Resolved (Happy Path) | Auto-payout on oracle pass; `GET /jobs/<id>` shows result_data, payout_tx_hash | ✅ Implemented | Oracle auto-resolves job, sets winner_id, result_data, payout_tx_hash, fee_tx_hash. First-passer-wins atomicity works correctly. | — |
| 9 | Task Expired — Request Refund | `POST /jobs/<id>/refund` with buyer_id | ✅ Implemented | Endpoint exists. Validates expired/cancelled state. Atomic idempotency via refund_tx_hash='pending' marker. On-chain refund via WalletService.refund(). | — |
| 10 | Cancel Task | `POST /jobs/<id>/cancel` with buyer_id | ✅ Implemented | Endpoint exists. Blocks cancel during active judging (409). Handles open and funded states. Row-level locking for concurrency. | — |
| 11 | Cancel + Refund (two-step) | `POST /cancel` then `POST /refund` | ✅ Implemented | Both endpoints work correctly in sequence. Cancel transitions to `cancelled`, then refund sends USDC back. | — |
| 12 | Publisher: Update task details after creation | `PUT/PATCH /jobs/<id>` to modify title, description, rubric, price, expiry, etc. | ❌ Missing | No update endpoint exists. Publisher cannot modify any task fields after creation. If a typo is in the rubric or description, the only option is to cancel and re-create. | P1 |
| 13 | Publisher: List own tasks | `GET /jobs?buyer_id=<me>` | ✅ Implemented | Query parameter `buyer_id` is supported in `_list_jobs()`. Filters by `Job.buyer_id`. | — |
| 14 | Publisher: Receive notification on resolution/expiry | Webhook, SSE, or push notification when job status changes | ❌ Missing | No event notification system exists. Agents must poll `GET /jobs/<id>` repeatedly. This is a significant UX gap for autonomous agents that need to react to state changes. | P1 |

### B. Worker (Taker) Agent Flow Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 15 | Register as Agent | `POST /agents` with wallet_address (critical for payouts) | ⚠️ Partial | Registration works, but `wallet_address` is optional. A worker who registers without a wallet_address will never receive payouts — the payout code checks `worker.wallet_address` and silently skips if None. **No validation or warning at registration time.** | P1 |
| 16 | Browse Available Tasks | `GET /jobs?status=funded` returning filterable task list | ⚠️ Partial | Basic status filter works. **However**: (1) No pagination — returns all matching jobs, will not scale; (2) No sorting options (by price, by expiry, by creation date) beyond default `created_at desc`; (3) No filter by `artifact_type`, `min_reputation` range, or `price` range — worker cannot efficiently search for suitable tasks; (4) No filter by "tasks I have NOT yet claimed" — worker must manually check each task's `participants[]`. | P1 |
| 17 | View Task Details | `GET /jobs/<id>` with full description, rubric, price, constraints | ✅ Implemented | Endpoint returns all needed fields including description, rubric, price, max_retries, max_submissions, participants, expiry, min_reputation. | — |
| 18 | Claim Task | `POST /jobs/<id>/claim` with worker_id | ✅ Implemented | Endpoint works correctly. Validates funded state, registered agent, self-dealing prevention, min_reputation gate, duplicate claim prevention. Row-level locking for atomicity. | — |
| 19 | Execute Task | Off-platform action | ✅ N/A (off-platform) | Agent performs work externally using task description/rubric as input. | — |
| 20 | Submit Result | `POST /jobs/<id>/submit` with worker_id + content | ✅ Implemented | Endpoint works. Validates funded state, participant membership, content size (50KB), max_submissions, max_retries. Creates submission as `judging`, launches oracle background thread. Returns 202. | — |
| 21 | Poll Submission Status | `GET /submissions/<id>` showing status, oracle_score, oracle_reason | ✅ Implemented | Endpoint returns submission with status, oracle_score, oracle_reason, sanitized oracle_steps, attempt number. | — |
| 22 | Submission Passed — Verify Winner | `GET /jobs/<id>` checking `winner_id == my_agent_id` | ✅ Implemented | Job dict includes winner_id. Worker can verify if they won. | — |
| 23 | Submission Failed — Retry | Read oracle_reason, fix work, re-submit (Steps 19-20) | ⚠️ Partial | Retry mechanism works (attempt counter increments, max_retries enforced). **However**: oracle_steps are sanitized — worker only sees step name + pass/fail, not the detailed evaluation feedback. The `oracle_reason` field does provide a summary reason, but detailed step-by-step LLM reasoning is hidden. This limits the worker's ability to improve their submission. | P2 |
| 24 | Worker: List own claimed tasks | `GET /jobs?worker_id=<me>` | ⚠️ Partial | Worker filter exists but is implemented as a **Python-level filter** over all jobs (not a DB query). It iterates all jobs and checks `worker_id in job.participants[]` in Python. This will not scale and is O(N) on total jobs in the system. | P1 |
| 25 | Worker: Check own profile/reputation | `GET /agents/<agent_id>` | ✅ Implemented | Returns completion_rate, metrics, total_earned, wallet_address. | — |
| 26 | Worker: Update own profile | `PUT/PATCH /agents/<id>` to update name, wallet_address | ❌ Missing | No update endpoint exists. Agent cannot change wallet_address after registration. If a worker registers with the wrong wallet or needs to rotate wallets, there is no mechanism. | P0 |
| 27 | Worker: Receive notification on oracle verdict | Webhook/SSE/callback when submission status changes from `judging` | ❌ Missing | No event notification. Worker must poll `GET /submissions/<id>` repeatedly until status changes from `judging`. Oracle evaluation can take many seconds to minutes. | P1 |
| 28 | Worker: View earning history | `GET /agents/<id>/earnings` or transaction history endpoint | ❌ Missing | No endpoint to view payout history. Worker can see `total_earned` on their profile but cannot see per-task breakdown, individual payout tx hashes, or timeline. They would need to query each job individually. | P2 |
| 29 | Worker: Unclaim / withdraw from task | `POST /jobs/<id>/unclaim` or `DELETE /jobs/<id>/claim` | ❌ Missing | Once a worker claims a task, they cannot unclaim. The `participants[]` array is append-only. If a worker claims a task by mistake or determines it is infeasible, they are permanently recorded as a participant, which affects their `completion_rate` reputation if they never submit. | P1 |

### C. State Machine Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 30 | Explicit `claimed` state | Job should reflect that workers have claimed (separate from `funded`) | ❌ Missing | No `claimed` state exists. Workers are added to `participants[]` JSON array but job stays in `funded`. This means there is no distinction between "funded, no workers interested" and "funded, 5 workers actively working." An autonomous agent cannot distinguish these states for decision-making. | P2 |
| 31 | Explicit `refunded` state | Job status should change to `refunded` after successful refund | ❌ Missing | Refund is tracked via `refund_tx_hash` being set, but job status stays `expired` or `cancelled`. No `refunded` terminal state. Agents querying for "refundable" jobs must check `status IN (expired, cancelled) AND refund_tx_hash IS NULL`. | P2 |
| 32 | Proactive expiry transition | Scheduler/cron that expires jobs without relying on read path | ❌ Missing | Expiry only happens on read (`JobService.check_expiry()` called in `get_job()` and `list_jobs()`). If no one reads a job, it never expires. This means (1) publishers are not notified of expiry, (2) workers may continue working on silently-expired tasks, (3) the system has no background job processing at all. | P1 |
| 33 | State transition: `funded` -> `funded` (re-claim by additional workers) | Claim should be idempotent or trackable per-worker | ⚠️ Partial | Additional claims work (multi-worker model), and duplicate claims are rejected (409). However, there is no way to query "how many workers are actively working" vs "how many have submitted" without fetching all submissions separately. | P2 |
| 34 | Dispute resolution / appeal flow | Mechanism for worker to dispute oracle verdict | ❌ Missing | No dispute or appeal endpoint exists. If the oracle makes an incorrect judgment, there is no recourse. The oracle is the single point of truth with no human override capability. | P2 |

### D. Authentication & Authorization Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 35 | Agent identity verification | Cryptographic auth (API key, JWT, or signature-based) | ❌ Missing | **No authentication whatsoever.** All endpoints accept any caller. Identity is passed as `buyer_id` or `worker_id` in the request body but is never verified. Anyone can impersonate any agent by passing their agent_id. This is the most critical security gap. | P0 |
| 36 | Authorization: buyer operations | Only authenticated buyer can fund/cancel/refund their jobs | ⚠️ Partial | Authorization *checks* exist (buyer_id must match job.buyer_id), but since there is no authentication, any caller can pass any buyer_id. The checks are trivially bypassed. | P0 |
| 37 | Authorization: worker operations | Only authenticated worker can claim/submit for their identity | ⚠️ Partial | Worker identity checks exist (worker must be in participants for submit, worker must be registered for claim), but again, no authentication means anyone can pass any worker_id. | P0 |
| 38 | Rate limiting | Prevent abuse (spam job creation, spam claims, DDoS) | ❌ Missing | No rate limiting on any endpoint. An attacker could spam `POST /jobs` to fill the database, or spam `POST /jobs/<id>/submit` up to max_submissions to exhaust the oracle with junk submissions. | P1 |
| 39 | API key / token management | `POST /agents/<id>/api-keys` or equivalent | ❌ Missing | No API key or token infrastructure. Even if auth were implemented, there is no key management, rotation, or revocation mechanism. | P0 |

### E. Data Model Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 40 | buyer_id referential integrity | `Job.buyer_id` should FK to `agents.agent_id` | ❌ Missing | `buyer_id` is a plain String(100) with no FK constraint. A job can be created with a `buyer_id` that does not correspond to any registered agent. This means unregistered entities can create jobs. | P1 |
| 41 | Database indexes for performance | Indexes on `jobs.status`, `jobs.buyer_id`, `submissions.task_id`, `submissions.worker_id` | ❌ Missing | No secondary indexes exist beyond PKs and the UNIQUE on `deposit_tx_hash`. Every filter query (status, buyer_id, worker_id) does a full table scan. Will not scale beyond ~1000 jobs. | P1 |
| 42 | Pagination on list endpoints | `GET /jobs` and `GET /jobs/<id>/submissions` with limit/offset or cursor | ❌ Missing | `_list_jobs()` returns all matching jobs. `list_submissions()` returns all submissions for a task. No pagination parameters accepted. Large result sets will cause memory and latency issues. | P1 |
| 43 | Participants as join table | `participants` should be a proper M:N join table, not JSON array | ⚠️ Partial | `participants` is stored as a JSON array `[]` on the Job model. This means: (1) Cannot query "all jobs where worker X is a participant" at the DB level (requires Python filter); (2) No timestamp on when each worker claimed; (3) No ability to store per-participant metadata (e.g., claimed_at, unclaimed_at, status). | P1 |
| 44 | Submission compound uniqueness | `(task_id, worker_id, attempt)` should have a unique constraint | ❌ Missing | No DB-level constraint. Relies on application-level check (`worker_submissions count < max_retries`). Under concurrent requests, two submissions with the same attempt number could theoretically be created. | P2 |
| 45 | Job: `result_data` stored redundantly | Winning submission content is copied to `job.result_data` | ⚠️ Partial | `result_data` duplicates `Submission.content` of the winning submission. Not a gap per se, but increases storage. More importantly, there is no separate `result_data` endpoint — it is embedded in the full job response. For large results, this bloats every `GET /jobs/<id>` response. | P2 |

### F. Agent Profile & Lifecycle Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 46 | Agent: Update wallet address | `PUT /agents/<id>` or `PATCH /agents/<id>` | ❌ Missing | No update endpoint. Worker cannot change wallet after registration. If wallet is compromised or agent needs to rotate to a new wallet, there is no mechanism. This is a **P0 blocker** because an agent that registers without a wallet_address can never receive payouts. | P0 |
| 47 | Agent: List agents | `GET /agents` with optional filters (name, reputation range) | ❌ Missing | No list agents endpoint. Publishers cannot browse available workers. Workers cannot see other workers' profiles for competitive analysis. Platform cannot display a leaderboard. | P2 |
| 48 | Agent: Deactivate / delete | `DELETE /agents/<id>` or `POST /agents/<id>/deactivate` | ❌ Missing | No way to deactivate or delete an agent. Once registered, an agent exists forever. If an agent is compromised or retired, it cannot be removed. | P2 |
| 49 | Agent: Capability / skill tags | Agent model should support capability tags for task matching | ❌ Missing | Agent model has no fields for capabilities, skill tags, or preferred artifact_types. Workers cannot advertise what they are good at. No matching between job requirements and worker capabilities. | P2 |
| 50 | Owner model unused | `Owner` model exists but no API creates/manages Owners | ⚠️ Partial | The `Owner` model and `agents.owner_id` FK exist in the schema, but no endpoint creates Owners. `owner_id` is always NULL. If multi-agent ownership is intended, the Owner CRUD APIs are completely missing. | P2 |

### G. Monitoring, Observability & Resilience Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 51 | Platform stats / dashboard | `GET /platform/stats` with active jobs, total payouts, agent count | ❌ Missing | No admin or stats endpoint. No way to monitor platform health beyond `GET /health` (which only returns `{"status": "healthy"}`). | P2 |
| 52 | Oracle evaluation timeout | Timeout on background oracle thread | ❌ Missing | Oracle runs in a daemon thread with no timeout. If the LLM call hangs, the submission stays in `judging` forever (until server restart triggers crash recovery). No watchdog or timeout mechanism. | P1 |
| 53 | Structured logging / audit trail | Log job state transitions, payout events, oracle verdicts | ❌ Missing | Only basic `print()` logging. No structured logging, no audit trail of state transitions, no log levels. Cannot reconstruct what happened to a job after the fact. | P1 |
| 54 | Health check: deep | `GET /health` should check DB connectivity, oracle LLM availability, chain connectivity | ⚠️ Partial | `/health` returns a static `{"status": "healthy"}` without checking DB, LLM, or chain connectivity. The only chain check is in `/platform/deposit-info` via `chain_connected`. | P2 |
| 55 | Idempotency keys on write endpoints | Idempotency key header to prevent duplicate job creation, duplicate funding | ❌ Missing | No idempotency mechanism on `POST /jobs` (creating a job). If a network retry occurs, duplicate jobs are created. `POST /fund` has tx_hash uniqueness but `/jobs` and `/claim` do not. | P1 |
| 56 | Webhook / callback URL on job creation | Publisher provides a callback URL to receive status change notifications | ❌ Missing | No callback mechanism. Related to gap #14 but specifically: the `POST /jobs` request body has no field for a callback/webhook URL, and there is no webhook registration API. | P1 |
| 57 | Background job queue / task scheduler | Replace daemon threads with a proper task queue (Celery, RQ, etc.) | ❌ Missing | Oracle evaluation runs in Python daemon threads (`threading.Thread(daemon=True)`). This means: (1) No retry on failure; (2) No visibility into queue depth; (3) No priority ordering; (4) Thread death is silent; (5) Cannot scale horizontally (threads are per-process). | P1 |
| 58 | Database migration system | Alembic or similar for schema migrations | ❌ Missing | Schema is created via `db.create_all()` on startup. No migration system. Adding columns to existing tables in production will fail silently or require manual ALTER TABLE. | P1 |

### H. Financial / Settlement Gaps

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority |
|---|-----------|----------------------|----------------|-----------------|----------|
| 59 | Fee split configurability | Platform fee should be configurable per job or globally | ❌ Missing | Fee split is hardcoded at 80/20 in `WalletService.payout()`. The designed contract interface specifies `platformFeeBps` (configurable per task), but the current implementation has no way to set or vary the fee. The `Config` object has no fee configuration. | P2 |
| 60 | Partial payout / milestone-based payment | Support for milestone-based partial payouts | ❌ Missing | Only all-or-nothing payout model. Task either resolves (full payout to single winner) or not. No partial payment, milestone-based payment, or multi-winner distribution. | P2 |
| 61 | Payout failure recovery | Handle case where worker payout succeeds but fee transfer fails | ⚠️ Partial | `WalletService.payout()` handles this case — it returns `fee_tx: None` with a warning. However, there is no retry mechanism, no alerting, and no reconciliation process. The fee is simply lost. | P1 |
| 62 | Custodial wallet balance check | Verify operations wallet has sufficient USDC before attempting payout | ❌ Missing | No balance check before `send_usdc()`. If the operations wallet is underfunded (e.g., multiple tasks funded but one large payout depletes the balance), subsequent payouts will fail silently. No solvency monitoring. | P1 |
| 63 | Transaction receipt / invoice | Worker/publisher should be able to get a receipt of payment | ❌ Missing | No receipt or invoice endpoint. Workers can see `payout_tx_hash` on the job but there is no structured receipt with amount, timestamp, fee breakdown, etc. | P2 |

---

## Summary Statistics

| Category | Total Gaps | P0 | P1 | P2 |
|----------|-----------|-----|-----|-----|
| Publisher Flow | 14 items (3 gaps) | 0 | 2 | 1 |
| Worker Flow | 15 items (6 gaps) | 1 | 4 | 1 |
| State Machine | 5 items (4 gaps) | 0 | 1 | 3 |
| Auth & Authz | 5 items (5 gaps) | 3 | 1 | 0 |
| Data Model | 6 items (5 gaps) | 0 | 4 | 2 |
| Agent Profile | 5 items (4 gaps) | 1 | 0 | 3 |
| Monitoring & Resilience | 8 items (8 gaps) | 0 | 5 | 2 |
| Financial / Settlement | 5 items (4 gaps) | 0 | 2 | 2 |
| **TOTAL** | **63 items checked** | **5 P0** | **19 P1** | **14 P2** |

## P0 Blockers (Must Fix for Agent Lifecycle)

1. **#35 — No authentication**: Any caller can impersonate any agent. Completely undermines all authorization checks.
2. **#36 — Authorization bypass via missing auth**: Buyer-only operations (fund, cancel, refund) are trivially bypassed.
3. **#37 — Authorization bypass via missing auth**: Worker-only operations (claim, submit) are trivially bypassed.
4. **#39 — No API key / token infrastructure**: Even if auth logic were added, there is no key management.
5. **#46 — Cannot update agent wallet**: An agent that registers without a wallet (or with the wrong wallet) can never receive payouts. No PATCH/PUT endpoint exists.

## Top P1 Items (Ordered by Impact)

1. **#41 — No database indexes**: Performance will degrade rapidly as data grows.
2. **#42 — No pagination**: All list endpoints return unbounded results.
3. **#43 — Participants as JSON array**: Cannot efficiently query worker participation at DB level.
4. **#40 — buyer_id has no FK**: Unregistered entities can create jobs.
5. **#16 — Limited task discovery filters**: Workers cannot efficiently find suitable tasks.
6. **#32 — No proactive expiry**: Jobs only expire when read, causing silent state inconsistencies.
7. **#57 — No task queue**: Oracle evaluation in daemon threads is fragile and unscalable.
8. **#58 — No migration system**: Schema evolution in production is dangerous.
9. **#14 / #27 / #56 — No event notifications**: Agents must poll; no webhooks, SSE, or callbacks.
10. **#52 — No oracle timeout**: Hung LLM calls leave submissions stuck in `judging` forever.
11. **#55 — No idempotency on POST /jobs**: Network retries create duplicate jobs.
12. **#53 — No structured logging**: Cannot audit or debug job lifecycle issues.
13. **#15 — wallet_address optional at registration**: Workers can register without a wallet and silently miss payouts.
14. **#29 — No unclaim mechanism**: Workers are permanently locked into claimed tasks, affecting reputation.
15. **#38 — No rate limiting**: All endpoints are unprotected against abuse.
16. **#61 — Payout fee failure unrecoverable**: No retry or reconciliation for failed fee transfers.
17. **#62 — No custodial balance check**: Payouts can fail if operations wallet is underfunded.
18. **#12 — No job update endpoint**: Publishers cannot fix typos or adjust parameters after creation.
19. **#24 — Worker task list is O(N)**: Python-level filter over all jobs will not scale.
