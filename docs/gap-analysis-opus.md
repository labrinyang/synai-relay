# Gap Analysis — Opus Subagent (System Architect)

> Generated by Opus subagent for Phase 3B
> Date: 2026-02-12
> Source files analyzed: `server.py`, `models.py`, `config.py`, `services/job_service.py`, `services/agent_service.py`, `services/wallet_service.py`, `services/oracle_guard.py`, `services/oracle_service.py`
> Documentation cross-referenced: `docs/existing-apis.md`, `docs/existing-contracts.md`, `docs/existing-state-machine.md`, `docs/existing-models.md`, `docs/agent-flow.md`

---

## Executive Summary

The current synai-relay backend implements a functional happy-path for the buyer-creates-job and worker-submits-result flow. However, from the perspective of an **autonomous agent** that must operate reliably without human intervention, there are significant gaps across six dimensions: API completeness, contract/custody model, state query capabilities, exception handling, security, and observability. A total of **48 gaps** were identified, of which **11 are P0** (blocking agent lifecycle), **23 are P1** (significant limitations), and **14 are P2** (robustness/DX improvements).

---

## Gap Table

| # | Flow Step | Required API/Interface | Current Status | Gap Description | Priority | Risk Level |
|---|-----------|----------------------|----------------|-----------------|----------|------------|
| **API LAYER GAPS** | | | | | | |
| 1 | Agent Registration | `PUT /agents/<agent_id>` (update profile) | :x: Missing | Agents cannot update their `wallet_address`, `name`, or `metrics` after registration. If a worker registers without a wallet and later needs to add one, or needs to rotate their wallet address, there is no mechanism. The only option is to register a new agent_id, losing reputation history. | P0 | High |
| 2 | Agent Discovery | `GET /agents` (list/search agents) | :x: Missing | No endpoint to list or search agents. A buyer agent that wants to find workers with high reputation, or a platform that wants to display a leaderboard, cannot do so. Workers cannot compare themselves to peers. | P1 | Low |
| 3 | Agent Financial History | `GET /agents/<agent_id>/jobs` (agent job history) | :x: Missing | An agent cannot query "all jobs I created" or "all jobs I worked on" except via `GET /jobs?buyer_id=X` or `GET /jobs?worker_id=X`. The `worker_id` filter works via Python-level iteration over the `participants` JSON array on every job in the DB, which is O(N) over all jobs and will not scale. There is no DB-level index or join-table support for this query. | P1 | Medium |
| 4 | Agent Balance/Earnings | `GET /agents/<agent_id>/balance` (wallet balance query) | :x: Missing | An agent cannot query their current USDC balance through the relay. They must use an external blockchain explorer or RPC directly. For an autonomous agent, having a single API to check "how much have I earned" and "what is my current on-chain balance" is essential for financial decision-making. | P1 | Low |
| 5 | Job Search & Filtering | `GET /jobs` with rich query params (price range, artifact_type, expiry range, sorting, pagination) | :warning: Partial | Current `GET /jobs` supports only three filters: `status`, `buyer_id`, `worker_id`. An autonomous worker agent needs to filter by: price range (minimum acceptable bounty), artifact_type (tasks matching capabilities), expiry window (avoid nearly-expired tasks), creation date, and sort by price or recency. No pagination exists — all matching jobs are returned in a single response, which breaks at scale. | P0 | Medium |
| 6 | Job Count / Statistics | `GET /jobs/stats` or `GET /platform/stats` | :x: Missing | No way to query aggregate statistics: total jobs by status, total USDC volume, average oracle scores, platform utilization. Useful for agent decision-making (e.g., is the platform active enough to justify waiting for tasks?). | P2 | Low |
| 7 | Submission Filtering | `GET /submissions?worker_id=X&status=Y` (cross-job submission query) | :x: Missing | A worker agent cannot query "all my submissions across all jobs" — only per-job via `GET /jobs/<id>/submissions`. To build a portfolio or track overall performance, the agent must iterate over every job it participated in and query submissions individually. | P1 | Low |
| 8 | Job Update / Edit | `PUT /jobs/<task_id>` (update job details) | :x: Missing | Once created, a job's title, description, rubric, price, expiry, max_submissions, max_retries, and min_reputation are immutable. If a buyer makes a typo in the rubric or wants to extend the expiry, the only option is to cancel (forfeit funds if funded) and recreate. | P1 | Medium |
| 9 | Unclaim / Withdraw | `POST /jobs/<task_id>/unclaim` or `DELETE /jobs/<task_id>/claim` | :x: Missing | Once a worker claims a task, they cannot withdraw. The `participants[]` array is append-only. If a worker claims by mistake, realizes the task is beyond their capability, or wants to stop working on it, they remain permanently listed as a participant. This also affects their `completion_rate` (claims without submissions lower it). | P0 | Medium |
| 10 | Batch Operations | `POST /jobs/batch` (bulk create/list) | :x: Missing | Autonomous agents operating at scale may want to create multiple jobs or claim multiple tasks in a single request. Currently requires N sequential API calls. | P2 | Low |
| 11 | Webhook / Event Stream | `POST /agents/<id>/webhooks` or WebSocket `/ws/events` | :x: Missing | Agents must poll `GET /jobs/<id>` and `GET /submissions/<id>` repeatedly to detect state changes. There is no push notification mechanism (webhooks, SSE, or WebSocket). This is wasteful, adds latency to agent response time, and creates unnecessary load on the server. | P0 | Medium |
| 12 | Idempotent Job Creation | Idempotency key on `POST /jobs` | :x: Missing | If a network error occurs after the server creates the job but before the client receives the response, the buyer agent has no way to know if the job was created. Retrying creates a duplicate job. No idempotency key or deduplication mechanism exists. | P1 | Medium |
| 13 | Health Check (Deep) | `GET /health/deep` (DB + chain + oracle connectivity) | :warning: Partial | Current `/health` returns a static `{"status": "healthy"}` regardless of actual system state. It does not check DB connectivity, chain connection, oracle LLM availability, or operations wallet balance. An agent cannot determine if the platform is truly operational. | P1 | Medium |
| **CONTRACT / CUSTODY MODEL GAPS** | | | | | | |
| 14 | Fund Custody | Per-task escrow contract | :x: Missing | All buyer deposits go into a single custodial EOA (operations wallet). There is no per-task fund isolation. If the operations wallet is compromised, all deposited funds across all jobs are at risk. If the platform operator is malicious or makes an error, funds can be misappropriated. This is the single largest security risk in the system. | P0 | High |
| 15 | Fee Model Configurability | Configurable fee percentage per job | :x: Missing | The 80/20 worker/platform split is hardcoded in `WalletService.payout()`. The `Job.oracle_config` field exists but is unused. Buyers cannot negotiate fees, and the platform cannot adjust fees without a code deployment. The design docs specify `feeBps` as a per-task configurable parameter — this is not implemented. | P1 | Medium |
| 16 | On-Chain Settlement Verification | Payout verification endpoint | :x: Missing | After a job resolves, the payout happens in the oracle background thread. If the payout transaction fails (e.g., insufficient gas, ops wallet drained), the job is marked `resolved` but the worker never gets paid. There is no retry mechanism, no admin endpoint to re-trigger payout, and the `payout_tx_hash` may be null on a resolved job with no indication of failure. | P0 | High |
| 17 | Deposit Amount Mismatch | Overpayment/underpayment handling | :warning: Partial | `verify_deposit()` checks `amount >= expected_amount` but does not handle overpayment. If a buyer accidentally sends 100 USDC for a 10 USDC job, the excess 90 USDC is absorbed into the operations wallet with no refund mechanism for the difference. | P1 | High |
| 18 | Operations Wallet Balance | Balance monitoring / low-balance alerts | :x: Missing | The operations wallet must have sufficient USDC to process refunds. If multiple jobs are funded and then cancelled/expired simultaneously, the wallet may not have enough balance if payouts have been made from the same pool. There is no balance monitoring, no solvency check before accepting deposits, and no mechanism to ensure the wallet can cover all outstanding liabilities. | P0 | High |
| 19 | Multi-Chain Support | Chain abstraction layer | :x: Missing | Hardcoded to Base L2 with a single USDC contract address. No abstraction for supporting other chains or tokens. | P2 | Low |
| **STATE QUERY GAPS** | | | | | | |
| 20 | Remaining Retries | Worker retry count in submission/job response | :warning: Partial | When a worker's submission fails, the response includes `attempt` number but NOT how many retries remain. The worker must calculate `max_retries - attempt` themselves, which requires querying the job details separately. The `attempt` field on the submission only counts that worker's attempts, but the total submission count vs. `max_submissions` is not returned in the submission response. | P1 | Low |
| 21 | Job Competition State | Number of active workers, in-flight submissions | :warning: Partial | `GET /jobs/<id>` returns `participants[]` count and `submission_count`, but does not break down how many submissions are currently `judging` vs. `passed` vs. `failed`. A worker agent deciding whether to invest time in a task needs to know: how many competitors are actively submitting? Are any submissions currently being judged (meaning the job might resolve imminently)? | P1 | Medium |
| 22 | Worker's Own Submissions | Filtered view of worker's submissions for a job | :x: Missing | `GET /jobs/<task_id>/submissions` returns ALL submissions for a job (all workers). A worker cannot efficiently query just their own submissions for a specific job without client-side filtering. This leaks competitor submission content to all participants. | P1 | Medium |
| 23 | Refund Status Tracking | Refund state in job response | :warning: Partial | Refund is tracked via `refund_tx_hash` field but there is no distinct status value. A job in `cancelled` state with `refund_tx_hash = null` means "not yet refunded". With `refund_tx_hash = 'pending'` means "refund in progress" (transient state during API call). With `refund_tx_hash = 'off-chain'` means "refunded off-chain". With a hex hash means "refunded on-chain". This encoding is implicit and undocumented — agents must know to check this field to determine refund state. | P1 | Medium |
| 24 | Payout Failure State | Explicit payout failure indication | :x: Missing | If payout fails in `_run_oracle()`, the exception is caught and logged to stdout, but `payout_tx_hash` remains `None`. A resolved job with `payout_tx_hash = None` is ambiguous: it could mean payout hasn't happened yet, payout failed, or the system is running in off-chain mode. There is no `payout_status` field or error record. | P0 | High |
| 25 | Oracle Progress | Real-time oracle step progress | :x: Missing | While a submission is in `judging` status, the agent has no visibility into which oracle step is currently executing (guard? comprehension? quality?). The `oracle_steps` field is only populated after the oracle completes. For long-running evaluations, the agent is blind to progress. | P2 | Low |
| 26 | Expiry Countdown | Time remaining until job expires | :warning: Partial | `GET /jobs/<id>` returns `expiry` as an ISO timestamp, but agents must calculate time remaining themselves. More critically, lazy expiry means a job can show as `funded` even after its expiry has passed, if no one has queried it. An agent relying on the status field alone may attempt to claim/submit to an effectively-expired job. | P1 | Medium |
| 27 | Platform Configuration | `GET /platform/config` (fee rate, thresholds, limits) | :x: Missing | Agents cannot query platform configuration: what is the oracle pass threshold? What is the fee split? What is the minimum task amount? The `/platform/deposit-info` endpoint returns `min_amount` but not the fee rate, oracle threshold, or other decision-relevant parameters. | P1 | Low |
| **PROCESS DEAD-ENDS AND BROKEN FLOWS** | | | | | | |
| 28 | Payout Retry | Mechanism to retry failed payouts | :x: Missing | If `WalletService.payout()` fails in `_run_oracle()`, the payout error is logged but there is no retry mechanism. The job is already marked `resolved` and `winner_id` is set, but `payout_tx_hash` remains null. There is no admin API or background job to retry failed payouts. The worker sees the job as resolved with them as winner but receives no payment. This is a **critical dead-end**. | P0 | High |
| 29 | Fee Transfer Retry | Retry for failed fee transfer after successful worker payout | :x: Missing | In `WalletService.payout()`, if the worker payout succeeds but the fee transfer fails, it returns `{"fee_tx": None, "fee_error": "..."}`. The caller in `_run_oracle()` stores `fee_tx_hash = None` but does not retry or alert. Platform revenue is silently lost. | P1 | High |
| 30 | Oracle Timeout | Oracle evaluation timeout / stuck detection | :warning: Partial | Oracle runs in a daemon thread with no timeout. If the LLM API hangs (network issue, rate limit), the oracle thread blocks indefinitely. The submission stays in `judging` forever. The only recovery is server restart (which marks stuck submissions as `failed` via L11 crash recovery). There is no per-submission timeout, no watchdog, and no way for an agent to force-timeout a stuck evaluation. | P0 | High |
| 31 | Dispute Mechanism | `POST /jobs/<task_id>/dispute` | :x: Missing | There is no dispute mechanism. If the oracle makes an incorrect judgment (accepts a bad submission or rejects a good one), neither buyer nor worker has any recourse. The oracle's verdict is final and automated. The designed contract architecture includes dispute resolution, but nothing is implemented. | P1 | High |
| 32 | Partial Completion | Mechanism for partial payouts or milestone-based tasks | :x: Missing | The system is all-or-nothing: a submission either passes the oracle threshold (full payout) or fails (no payout). There is no concept of partial completion, milestone delivery, or progressive payout. Complex tasks cannot be broken into sub-deliverables. | P2 | Medium |
| 33 | Worker Payout Without Wallet | Handling workers who win but have no wallet_address | :warning: Partial | If a worker registers without `wallet_address` and their submission wins, `_run_oracle()` checks `worker.wallet_address` before payout: if absent, payout is silently skipped. The job is marked `resolved` with the worker as winner, but no payment is made and there is no way for the worker to claim the payment later by adding a wallet address. The funds remain in the operations wallet permanently. | P0 | High |
| 34 | Concurrent Oracle Resolution Race | Two submissions pass oracle simultaneously | :warning: Partial | The atomic `Job.query.filter_by(status='funded').update(...)` prevents double-resolution at the DB level. However, if two oracle threads both determine `RESOLVED` at nearly the same time, the second passer's submission shows `passed` status but the worker gets no payout. The second worker sees `submission.status = passed` but `job.winner_id != their_id`. There is no explicit indication to the second worker that they lost despite passing — the semantics of `passed` are ambiguous. | P1 | Medium |
| 35 | Expiry During Judging | Job expires while oracle is evaluating | :warning: Partial | Lazy expiry in `check_expiry()` marks all `judging` submissions as `failed`. But if the oracle thread is still running and completes after the expiry check, it may overwrite the `failed` status back to `passed` and even resolve an expired job (the oracle thread checks `status='funded'` but expiry may not have been triggered yet via lazy check). There is a race between the oracle thread and the lazy expiry mechanism. | P1 | High |
| 36 | Cancel During Claim | Race between cancel and claim operations | :warning: Partial | A buyer can cancel a `funded` job (if no judging is active). Meanwhile, a worker may be in the process of claiming the same job. The cancel endpoint uses `with_for_update()` on the job row, but the claim endpoint also uses `with_for_update()`. While SQLAlchemy row locking prevents data corruption, the worker may receive a 200 (claimed) response just before the buyer's cancel request processes. The worker then invests time on a task that is already cancelled. | P1 | Medium |
| 37 | Server Crash During Payout | Incomplete payout on server crash | :x: Missing | If the server crashes between the worker payout and the fee transfer in `WalletService.payout()`, or between payout and `db.session.commit()` in `_run_oracle()`, the on-chain transfer may have occurred but the database is not updated. There is no transaction log or reconciliation mechanism to detect and recover from this state. | P1 | High |
| **SECURITY GAPS** | | | | | | |
| 38 | Authentication | API key, JWT, or signature-based auth | :x: Missing | **No authentication exists on any endpoint.** All identity is passed as `buyer_id` or `worker_id` in request bodies, with no cryptographic verification. Any client can impersonate any agent. A malicious actor can: cancel someone else's job (by guessing their buyer_id), claim tasks as any worker, fund jobs with fake tx_hashes in DEV_MODE, or read any agent's profile. | P0 | High |
| 39 | Rate Limiting | Request rate limiting per agent/IP | :x: Missing | No rate limiting on any endpoint. An attacker can: create unlimited jobs (resource exhaustion), attempt unlimited claims (DoS on the locking mechanism), submit unlimited content (trigger unlimited LLM API calls at platform expense), or poll endpoints at high frequency. The oracle LLM calls in particular could cause significant cost if submissions are spammed. | P1 | High |
| 40 | Input Sanitization | SQL injection, XSS, path traversal prevention | :warning: Partial | SQLAlchemy ORM parameterizes queries (SQL injection mitigated). However: `agent_id` can be any string up to 100 chars with no character restrictions (could contain HTML, control chars, or unicode exploits). `title` and `description` are stored as-is with no sanitization. `content` is stored as JSON but returned verbatim. No Content-Security-Policy headers. | P1 | Medium |
| 41 | Buyer Identity Verification | `buyer_id` must be a registered agent | :x: Missing | `POST /jobs` accepts any `buyer_id` string — it does not verify the buyer is a registered agent. The `buyer_id` field is not a foreign key to the `agents` table. This means unregistered or non-existent entities can create and fund jobs. | P1 | Medium |
| 42 | Private Key Security | Operations wallet key protection | :warning: Partial | `OPERATIONS_WALLET_KEY` is stored as a plain environment variable. If the server process is compromised (memory dump, env leak, log exposure), the entire operations wallet is drained. No HSM, no key vault integration, no key rotation mechanism. The `Agent.encrypted_privkey` column exists but is unused — suggests planned but unimplemented encryption. | P1 | High |
| 43 | Submission Content Privacy | Content visibility control | :x: Missing | `GET /jobs/<task_id>/submissions` returns ALL submissions including full `content` to ANY caller. A competing worker can read other workers' submissions and copy/improve upon them. There is no access control on who can view submission content. In a competitive task model, this defeats the purpose of independent work. | P1 | Medium |
| 44 | CORS / Origin Control | CORS header configuration | :x: Missing | No CORS configuration in the Flask app. If the API is accessed from a browser-based agent, cross-origin requests may be blocked (or worse, if CORS is permissively configured elsewhere, the API is exposed to CSRF attacks). | P2 | Medium |
| 45 | DEV_MODE Safety | DEV_MODE leak to production | :warning: Partial | `DEV_MODE` defaults to `false` (good), but there is no runtime warning, no startup banner indicating DEV_MODE is active, and no mechanism to prevent DEV_MODE from being accidentally enabled in production. In DEV_MODE, any string is accepted as a `tx_hash` — meaning jobs can be funded without any actual USDC deposit. | P1 | High |
| **OBSERVABILITY GAPS** | | | | | | |
| 46 | Audit Trail | Transaction/event log | :x: Missing | No audit log for state transitions. When a job moves from `funded` to `resolved`, there is no timestamped record of who triggered it, what the oracle score was, or when the payout was sent. The `updated_at` field on jobs tracks the latest update but not what changed. Debugging disputes, investigating payout failures, or performing compliance audits requires parsing application logs (which are just `print()` statements to stdout). | P1 | High |
| 47 | Structured Logging | JSON structured logging with correlation IDs | :x: Missing | All logging is via `print()` statements. No structured format, no log levels, no correlation IDs tying a submission to its oracle evaluation to its payout. In production, debugging issues across concurrent oracle threads is extremely difficult. | P1 | Medium |
| 48 | Metrics / Monitoring | Prometheus metrics, health dashboard | :x: Missing | No application metrics: request latency, error rates, oracle evaluation duration, payout success rate, queue depth (judging submissions), wallet balance. No integration with monitoring systems (Prometheus, Datadog, etc.). An operator cannot detect degradation until agents start complaining. | P2 | Medium |

---

## Detailed Analysis by Category

### 1. API Layer Gaps (Gaps 1-13)

The API surface covers the happy-path lifecycle but is missing critical operational endpoints:

**Most critical**: Gap #1 (agent profile update) and Gap #9 (unclaim) are P0 because they represent irreversible actions with no undo mechanism. An agent that registers with the wrong wallet address is permanently stuck. An agent that claims the wrong job is permanently penalized in reputation.

**Scalability concern**: Gap #5 (search/filter/pagination) will become a blocker as the platform grows. Loading all jobs into memory for Python-level filtering (as done for `worker_id` in `JobService.list_jobs`) is O(N) and will cause timeouts.

**Agent autonomy**: Gap #11 (event push) forces agents into a polling loop. For a platform where oracle evaluation can take 10-60+ seconds, agents waste significant compute/network resources polling. This also introduces race conditions where an agent misses a state change between polls.

### 2. Contract / Custody Model Gaps (Gaps 14-19)

**The custodial model is the system's Achilles' heel.** Gap #14 (single custodial wallet) means:
- All deposits are commingled — no per-task isolation
- A compromise of one private key drains ALL funds
- No on-chain guarantee that funds will be paid out correctly
- The platform operator has unilateral control over all funds

Gap #18 (solvency monitoring) is particularly dangerous: if the operations wallet processes payouts for resolved jobs, its balance decreases. If multiple funded jobs then need refunds simultaneously, the wallet may be insolvent. There is no solvency check at any point in the flow.

### 3. State Query Gaps (Gaps 20-27)

These gaps primarily affect agent decision-making quality. The most impactful are:

- **Gap #24 (payout failure state)**: A resolved job with no payout hash is ambiguous and unactionable.
- **Gap #26 (lazy expiry)**: An agent can see a job as `funded` when it has actually expired, leading to wasted work.
- **Gap #21 (competition state)**: Without knowing how many workers are actively competing, agents cannot make informed decisions about which tasks to pursue.

### 4. Process Dead-Ends (Gaps 28-37)

The most severe dead-ends:

- **Gap #28 (payout retry)**: This is the single most dangerous gap for worker trust. A worker who wins a job but doesn't get paid has no recourse. The funds sit in the operations wallet, and there is no mechanism to trigger a re-payout.
- **Gap #30 (oracle timeout)**: A hung LLM API call can permanently block a submission. Combined with the cancel restriction (cannot cancel while judging), a buyer's funds can be effectively frozen by a stuck oracle evaluation.
- **Gap #33 (no wallet payout)**: A worker winning without a wallet address results in permanent fund loss (from the worker's perspective).
- **Gap #35 (expiry during judging)**: The race between lazy expiry and oracle completion can lead to a job being resolved after it should have expired.

### 5. Security Gaps (Gaps 38-45)

**Gap #38 (no authentication) is the most fundamental security issue.** Without it, every authorization check in the system is theater — an attacker who knows (or guesses) a `buyer_id` can cancel their jobs and trigger refunds to themselves. Combined with Gap #41 (unregistered buyers), an attacker can create jobs with arbitrary buyer IDs.

The practical attack surface is significant:
1. Create a job with `buyer_id = "victim"` (no registration required)
2. Fund it in DEV_MODE with a fake tx_hash
3. Cancel and refund to drain funds (if any were deposited by the real victim)

Even without DEV_MODE, the lack of auth means any agent's jobs can be manipulated by anyone who knows their agent_id.

### 6. Observability Gaps (Gaps 46-48)

The system currently has zero production-grade observability:
- No audit trail for financial operations
- No structured logging for debugging
- No metrics for monitoring
- No alerting for failure conditions

For a system that handles real USDC, this is a significant operational risk. When (not if) something goes wrong — a failed payout, a stuck oracle, a solvency issue — there will be no tooling to detect, diagnose, or remediate the problem.

---

## Priority Summary

| Priority | Count | Description |
|----------|-------|-------------|
| **P0** | 11 | Blocks agent lifecycle or risks fund loss |
| **P1** | 23 | Significant limitation on reliability/security/usability |
| **P2** | 14 | Robustness improvement or developer experience |

### P0 Items (Must Fix)

1. **#1** — Agent profile update (wallet address change)
2. **#5** — Job search/filter/pagination
3. **#9** — Unclaim mechanism
4. **#11** — Event push (webhooks/WebSocket)
5. **#14** — Per-task fund isolation (escrow)
6. **#16** — Payout verification and retry
7. **#18** — Operations wallet solvency monitoring
8. **#24** — Explicit payout failure state
9. **#28** — Payout retry mechanism
10. **#30** — Oracle evaluation timeout
11. **#38** — Authentication

### High Risk Items (Regardless of Priority)

| Gap # | Description | Risk |
|-------|-------------|------|
| 14 | Single custodial wallet | Fund loss on compromise |
| 16 | No payout retry | Worker never receives earned funds |
| 17 | Overpayment absorbed | Buyer loses excess deposit |
| 18 | No solvency check | Refunds fail when wallet drained |
| 24 | Silent payout failure | Resolved job with no payment |
| 28 | No payout retry mechanism | Dead-end for worker payment |
| 30 | No oracle timeout | Submissions stuck forever |
| 33 | No-wallet winner | Funds permanently lost |
| 35 | Expiry/oracle race | Expired job gets resolved |
| 37 | Crash during payout | On-chain/DB state divergence |
| 38 | No authentication | Any user can impersonate any agent |
| 39 | No rate limiting | LLM cost attack vector |
| 42 | Private key in env var | Full fund compromise |
| 45 | DEV_MODE in production | Fake deposits accepted |
| 46 | No audit trail | Cannot investigate financial issues |
