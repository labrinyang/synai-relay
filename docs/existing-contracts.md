# Existing Smart Contract Interfaces — synai-relay

> Auto-generated by Phase 1.3 capability survey

## Current Status: NO DEPLOYED CONTRACTS

The running server (`server.py`) does **not** use any smart contracts. All on-chain operations are direct USDC ERC-20 transfers managed by `wallet_service.py` through a custodial operations wallet.

---

## A. Implemented On-Chain Interface (wallet_service.py)

The current "on-chain" capability is a **custodial USDC transfer layer** — NOT smart contract escrow.

### WalletService (services/wallet_service.py)

| Method | Signature | Description | On-Chain Action |
|---|---|---|---|
| `is_connected()` | `() → bool` | Check if Web3 + ops key configured | None (read) |
| `get_ops_address()` | `() → str` | Return operations wallet address | None (read) |
| `verify_deposit(tx_hash, expected_amount)` | `(str, Decimal) → dict` | Verify USDC deposit tx | Read: `Transfer` event log, 12 confirmation check |
| `send_usdc(to_address, amount)` | `(str, Decimal) → str` | Send USDC from ops wallet | Write: `USDC.transfer(to, amount)` |
| `payout(worker_address, task_price)` | `(str, Decimal) → dict` | 80/20 split payout + fee | Write: 2x `USDC.transfer()` |
| `refund(depositor_address, amount)` | `(str, Decimal) → str` | Full refund to depositor | Write: `USDC.transfer()` |

### On-Chain Configuration

| Variable | Default | Description |
|---|---|---|
| `RPC_URL` | `""` | Base L2 RPC endpoint |
| `USDC_CONTRACT` | `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913` | Base USDC address |
| `OPERATIONS_WALLET_ADDRESS` | `""` | Custodial wallet receiving deposits |
| `OPERATIONS_WALLET_KEY` | `""` | Private key for sending payouts |
| `FEE_WALLET_ADDRESS` | `""` | Receives 20% platform fee |

### USDC ABI Used (Minimal)

Only 3 entries from the USDC ERC-20 contract:
1. `Transfer(address indexed from, address indexed to, uint256 value)` — Event
2. `transfer(address to, uint256 value) → bool` — Function
3. `decimals() → uint8` — View

### Flow

```
Buyer sends USDC → Operations Wallet (verified via Transfer event logs)
                         ↓
               Platform holds funds (custodial)
                         ↓
           Oracle resolves task → WalletService.payout()
                         ↓
              80% → Worker wallet (USDC.transfer)
              20% → Fee wallet (USDC.transfer)
```

### Key Characteristics

- **Custodial**: Platform holds all funds in a single EOA (operations wallet)
- **No escrow contract**: Funds are not locked per-task; single wallet balance covers all tasks
- **Fee split hardcoded**: 80% worker / 20% platform in `WalletService.payout()`
- **Nonce lock**: `threading.Lock()` prevents concurrent transaction nonce collisions
- **Graceful degradation**: If `RPC_URL` empty, runs in off-chain mode (no chain verification)
- **DEV_MODE**: Accepts any `tx_hash` without on-chain verification

---

## B. Designed Contract Interfaces (NOT implemented)

Full design exists in `docs/design/smart-contracts.md`. These are **design-phase only** — no `.sol` files exist in the repository.

### Designed Contracts

| Contract | Purpose | Phase |
|---|---|---|
| **ITaskRegistry** | Task lifecycle state machine (create → fund → claim → submit → verdict → settle) | Phase 1-2 |
| **IEscrowVault** | USDC escrow per-task (deposit, release with fee, refund) | Phase 1 |
| **IVoucherToken** | Soulbound ERC-5192 NFT for task claim proof | Phase 2 |
| **ICVSOracle** | Authorized oracle verdict submission | Phase 1-2 |

### Designed State Machine (10 states)

| State | Value | Current Backend Equivalent |
|---|---|---|
| CREATED | 0 | `open` |
| FUNDED | 1 | `funded` |
| CLAIMED | 2 | *(no separate state — workers added to `participants[]`)* |
| SUBMITTED | 3 | *(no separate state — Submission model tracks this)* |
| ACCEPTED | 4 | *(no separate state — oracle auto-settles)* |
| SETTLED | 5 | `resolved` |
| REJECTED | 6 | *(Submission.status=`failed`, Job stays `funded`)* |
| EXPIRED | 7 | `expired` |
| CANCELLED | 8 | `cancelled` |
| REFUNDED | 9 | *(no separate state — `refund_tx_hash` set on cancelled/expired job)* |

### Design vs. Implementation Gap

| Feature | Designed (smart-contracts.md) | Implemented (wallet_service.py) |
|---|---|---|
| Fund custody | Per-task escrow in EscrowVault contract | Single custodial EOA wallet |
| Claim proof | Soulbound ERC-5192 voucher NFT | `participants[]` JSON array in DB |
| Fee model | Per-task `platformFeeBps` (configurable) | Hardcoded 80/20 split |
| Oracle verdict | On-chain `submitVerdict()` by authorized oracle | Off-chain LLM oracle in background thread |
| Settlement | `settle()` from escrow contract | Direct `USDC.transfer()` from ops wallet |
| Expiry | `markExpired()` by keepers, on-chain timestamp check | Lazy expiry on read (`JobService.check_expiry()`) |
| State granularity | 10 states (CREATED through REFUNDED) | 5 states (open, funded, resolved, expired, cancelled) |

### Previously Attempted Contracts (Phase 1 branch)

According to `docs/design/phase1-review-report.md`, `TaskEscrow.sol` (~194 lines) and `CVSOracle.sol` (~59 lines) were implemented on branch `upstream/feature/onchain-settlement-phase1` but had critical issues:
- CVSOracle enforces one verdict per taskId, but TaskEscrow allows retries → retry flow broken
- Missing: Pausable, nonReentrant on `onVerdictReceived`, CEI fix in `fundTask`, feeBps bounds, zero-address checks
- Only 19/43 required tests present (44% coverage)
- MockUSDC uses wrong decimals (18 vs 6)

These contracts are **NOT merged** into the current codebase.
