# Project Structure — synai-relay

> Auto-generated by Phase 1.1 capability survey

## Overview

**synai-relay** is a Python/Flask task marketplace backend (V2 multi-worker oracle architecture) with on-chain USDC settlement on Base L2. It allows buyers to post tasks with escrow, workers to claim and submit results, and an LLM-based oracle to judge submissions automatically.

## Tech Stack

| Layer | Technology | Version |
|---|---|---|
| Language | Python | 3.12.8 |
| Web Framework | Flask | 3.0.2 |
| ORM | Flask-SQLAlchemy / SQLAlchemy | 3.1.1 / 2.0+ |
| Database | SQLite (dev) | configurable via `DATABASE_URL` |
| Web3 | web3.py / eth-account | 6.0+ / 0.11.0 |
| WSGI Server | gunicorn | 21.2.0 |
| Test Framework | pytest | — |
| Deployment | Heroku-style (Procfile + runtime.txt) | — |

## Directory Tree

```
synai-relay/
├── server.py                    # Flask app entry point + ALL route handlers (748 lines)
├── config.py                    # Config class, env vars (26 lines)
├── models.py                    # SQLAlchemy models: Owner, Agent, Job, Submission (93 lines)
├── requirements.txt             # pip dependencies (9 packages)
├── Procfile                     # Heroku process definition (gunicorn)
├── runtime.txt                  # Python 3.12.8
│
├── services/                    # Business logic layer
│   ├── __init__.py              # Empty marker
│   ├── agent_service.py         # Agent registration + reputation calculation (75 lines)
│   ├── job_service.py           # Job CRUD, listing, lazy expiry check (89 lines)
│   ├── oracle_guard.py          # Submission safety: regex + LLM dual-layer guard (131 lines)
│   ├── oracle_prompts.py        # LLM prompt templates for 6-step oracle (153 lines)
│   ├── oracle_service.py        # 6-step oracle evaluation pipeline (159 lines)
│   └── wallet_service.py        # On-chain USDC: deposit verify, payout, fee, refund (169 lines)
│
├── tests/                       # pytest test suite
│   ├── __init__.py              # Empty marker
│   ├── conftest.py              # Fixtures (Flask app, DB, mocks)
│   ├── test_oracle_guard.py     # Guard regex + LLM tests
│   ├── test_oracle_service.py   # Oracle evaluation tests
│   └── test_wallet_service.py   # Wallet payout/refund/verify tests
│
├── scripts/demo/                # Standalone E2E demo scripts (not pytest)
│   ├── e2e_v2_happy_path.py     # Normal flow: create → fund → claim → submit → resolve
│   ├── e2e_v2_cancel_refund.py  # Cancel and refund flows
│   └── e2e_v2_multiworker.py    # Multi-worker concurrent submission scenario
│
├── templates/                   # HTML UI assets + documentation templates
│   ├── index.html               # Web UI
│   ├── landing.html             # Landing page
│   ├── agent_manual.md          # Agent manual template
│   └── install.md               # Install guide template
│
├── docs/                        # Design documents (gitignored)
│   ├── design/                  # Architecture + review docs
│   │   ├── on-chain-settlement-architecture.md
│   │   ├── phase1-execution-prompt.md
│   │   ├── phase1-review-report.md
│   │   ├── smart-contracts.md
│   │   ├── agent-devil-advocate.md
│   │   ├── agent-oracle-specialist.md
│   │   ├── agent-product-engineer.md
│   │   ├── agent-protocol-architect.md
│   │   └── agent-security-reviewer.md
│   ├── plans/                   # Execution plans
│   └── reviews/                 # Code review outputs
│
├── doc/plan/                    # Additional planning docs
│   └── agent-settlement-final-plan.md
│
└── .claude/                     # Claude Code config
    └── settings.local.json
```

## Architecture Summary

### Request Flow

```
Client → Flask routes (server.py) → Service layer (services/) → DB (SQLAlchemy) + Chain (web3.py)
```

### Key Design Patterns

1. **Monolithic server.py** — All 14 route handlers in a single file (no Blueprint separation)
2. **Service layer** — Business logic extracted into `services/` (agent, job, oracle, wallet)
3. **Background oracle** — Submissions judged in daemon `threading.Thread` (not Celery/RQ)
4. **Singleton WalletService** — `get_wallet_service()` returns a module-level singleton
5. **Lazy expiry** — Jobs expire on read (no cron/scheduler); `JobService.check_expiry()` called on list/get
6. **Dual-layer guard** — Programmatic regex scan + LLM semantic analysis before oracle evaluation
7. **Atomic operations** — `with_for_update()` row locks for claim, cancel, refund race prevention
8. **Crash recovery** — Stuck `judging` submissions reset to `failed` on startup

### On-Chain Settlement (Current)

- **Custodial model**: Buyer sends USDC to operations wallet, platform relays payouts
- **No smart contracts deployed** — settlement is direct USDC transfers via `wallet_service.py`
- **Fee split**: 80% worker / 20% platform (hardcoded in `WalletService.payout()`)
- **DEV_MODE**: When `true`, skips on-chain verification (accepts any `tx_hash`)

### Smart Contracts (Design Phase Only)

- `TaskEscrow.sol` and `CVSOracle.sol` exist in design docs but are NOT integrated into the running server
- Phase 1 on-chain settlement architecture documented in `docs/design/`
