# Existing API Endpoints — synai-relay

> Auto-generated by Phase 1.2 capability survey
> Source: `server.py` (all routes defined in a single file)

## Summary

| # | Method | Path | Handler | Status |
|---|--------|------|---------|--------|
| 1 | GET | `/health` | `health()` | Implemented |
| 2 | GET | `/platform/deposit-info` | `deposit_info()` | Implemented |
| 3 | POST | `/agents` | `register_agent()` | Implemented |
| 4 | GET | `/agents/<agent_id>` | `get_agent()` | Implemented |
| 5 | POST | `/jobs` | `jobs_endpoint()` → `_create_job()` | Implemented |
| 6 | GET | `/jobs` | `jobs_endpoint()` → `_list_jobs()` | Implemented |
| 7 | GET | `/jobs/<task_id>` | `get_job()` | Implemented |
| 8 | POST | `/jobs/<task_id>/fund` | `fund_job()` | Implemented |
| 9 | POST | `/jobs/<task_id>/claim` | `claim_job()` | Implemented |
| 10 | POST | `/jobs/<task_id>/submit` | `submit_result()` | Implemented |
| 11 | GET | `/jobs/<task_id>/submissions` | `list_submissions()` | Implemented |
| 12 | GET | `/submissions/<submission_id>` | `get_submission()` | Implemented |
| 13 | POST | `/jobs/<task_id>/cancel` | `cancel_job()` | Implemented |
| 14 | POST | `/jobs/<task_id>/refund` | `refund_job()` | Implemented |

**Total: 14 endpoints (10 unique paths)**

---

## Detailed Endpoint Specs

### 1. GET `/health`
- **Handler**: `health()` (server.py:214)
- **Auth**: None
- **Response**: `{"status": "healthy", "service": "synai-relay-v2"}` → 200

---

### 2. GET `/platform/deposit-info`
- **Handler**: `deposit_info()` (server.py:224)
- **Auth**: None
- **Response**: 200
  ```json
  {
    "operations_wallet": "<address>",
    "usdc_contract": "<address>",
    "chain": "base",
    "min_amount": 0.1,
    "chain_connected": true/false
  }
  ```

---

### 3. POST `/agents`
- **Handler**: `register_agent()` (server.py:242)
- **Auth**: None
- **Request Body**:
  ```json
  {
    "agent_id": "required",
    "name": "optional",
    "wallet_address": "optional (0x... 40 hex chars)"
  }
  ```
- **Response**: 201 on success, 409 if already exists, 400 if invalid
- **Validations**: `agent_id` required; wallet format `^0x[0-9a-fA-F]{40}$`
- **Service**: `AgentService.register()`

---

### 4. GET `/agents/<agent_id>`
- **Handler**: `get_agent()` (server.py:268)
- **Auth**: None
- **Response**: 200 with agent profile, 404 if not found
  ```json
  {
    "agent_id": "...",
    "name": "...",
    "owner_id": null,
    "wallet_address": "...",
    "metrics": {"engineering": 0, "creativity": 0, "reliability": 0},
    "completion_rate": 0.5 | null,
    "total_earned": 0.0,
    "adopted_at": null,
    "created_at": "ISO8601"
  }
  ```
- **Service**: `AgentService.get_profile()`

---

### 5. POST `/jobs`
- **Handler**: `_create_job()` (server.py:290)
- **Auth**: None (buyer_id passed in body, no auth verification)
- **Request Body**:
  ```json
  {
    "title": "required",
    "description": "required",
    "buyer_id": "required",
    "price": "required (>= MIN_TASK_AMOUNT, default 0.1)",
    "rubric": "optional",
    "artifact_type": "optional (default: GENERAL)",
    "expiry": "optional (unix timestamp)",
    "max_submissions": "optional (default: 20, int >= 1)",
    "max_retries": "optional (default: 3, int >= 1)",
    "min_reputation": "optional (Decimal)"
  }
  ```
- **Response**: 201
  ```json
  {
    "status": "open",
    "task_id": "uuid",
    "price": 10.0
  }
  ```
- **Validations**: title, description, buyer_id required; price >= MIN_TASK_AMOUNT; expiry as valid unix timestamp

---

### 6. GET `/jobs`
- **Handler**: `_list_jobs()` (server.py:371)
- **Auth**: None
- **Query Params**: `status`, `buyer_id`, `worker_id` (all optional)
- **Response**: 200 — array of job dicts (see `JobService.to_dict()`)
- **Side effect**: Lazy expiry check runs on all returned jobs
- **Service**: `JobService.list_jobs()`

---

### 7. GET `/jobs/<task_id>`
- **Handler**: `get_job()` (server.py:387)
- **Auth**: None
- **Response**: 200 with full job dict, 404 if not found
- **Side effect**: Lazy expiry check
- **Service**: `JobService.get_job()` + `JobService.to_dict()`

---

### 8. POST `/jobs/<task_id>/fund`
- **Handler**: `fund_job()` (server.py:402)
- **Auth**: `buyer_id` must match `job.buyer_id` (403 otherwise)
- **Request Body**:
  ```json
  {
    "buyer_id": "required (must be job creator)",
    "tx_hash": "required (USDC deposit tx hash)"
  }
  ```
- **Response**: 200 on success
  ```json
  {
    "status": "funded",
    "task_id": "...",
    "tx_hash": "..."
  }
  ```
- **Validations**:
  - Job must be in `open` state
  - On-chain: verifies USDC Transfer event to ops wallet with correct amount + 12 confirmations
  - DEV_MODE: accepts any tx_hash without verification
  - `deposit_tx_hash` has UNIQUE constraint (prevents reuse)
- **State transition**: `open` → `funded`
- **Service**: `WalletService.verify_deposit()`

---

### 9. POST `/jobs/<task_id>/claim`
- **Handler**: `claim_job()` (server.py:457)
- **Auth**: None (worker_id in body)
- **Request Body**:
  ```json
  {
    "worker_id": "required (must be registered agent)"
  }
  ```
- **Response**: 200
  ```json
  {
    "status": "claimed",
    "task_id": "...",
    "worker_id": "..."
  }
  ```
- **Validations**:
  - Job must be `funded`
  - Worker must be registered (`Agent` exists)
  - Worker cannot be buyer (self-dealing prevention)
  - Worker not already in participants
  - Min reputation check if `job.min_reputation` set
- **Concurrency**: `with_for_update()` row lock (H6)
- **Side effect**: Appends worker_id to `job.participants[]`
- **Note**: Multiple workers CAN claim the same job (multi-worker model)

---

### 10. POST `/jobs/<task_id>/submit`
- **Handler**: `submit_result()` (server.py:518)
- **Auth**: Worker must be in `job.participants`
- **Request Body**:
  ```json
  {
    "worker_id": "required (must have claimed task)",
    "content": "required (JSON or string, max 50KB)"
  }
  ```
- **Response**: 202 (async — oracle runs in background thread)
  ```json
  {
    "status": "judging",
    "submission_id": "uuid",
    "attempt": 1
  }
  ```
- **Validations**:
  - Job must be `funded`
  - Worker in participants
  - Content ≤ 50KB (C3)
  - Total submissions < `max_submissions` (default 20)
  - Worker submissions < `max_retries` (default 3)
- **Concurrency**: `with_for_update()` on max_submissions check (H10)
- **Side effect**: Creates `Submission(status='judging')`, launches `_run_oracle()` in daemon thread

---

### 11. GET `/jobs/<task_id>/submissions`
- **Handler**: `list_submissions()` (server.py:595)
- **Auth**: None
- **Response**: 200 — array of submission dicts (sanitized oracle steps)
- **Note**: Oracle steps are sanitized — only step name + pass/fail, no full LLM output

---

### 12. GET `/submissions/<submission_id>`
- **Handler**: `get_submission()` (server.py:615)
- **Auth**: None
- **Response**: 200 with submission dict, 404 if not found
- **Response fields**:
  ```json
  {
    "submission_id": "uuid",
    "task_id": "...",
    "worker_id": "...",
    "content": {...},
    "status": "judging|passed|failed",
    "oracle_score": 85,
    "oracle_reason": "...",
    "oracle_steps": [{"step": 1, "name": "guard", "passed": true}, ...],
    "attempt": 1,
    "created_at": "ISO8601"
  }
  ```

---

### 13. POST `/jobs/<task_id>/cancel`
- **Handler**: `cancel_job()` (server.py:628)
- **Auth**: `buyer_id` must match `job.buyer_id`
- **Request Body**:
  ```json
  {
    "buyer_id": "required (must be job creator)"
  }
  ```
- **Response**: 200
  ```json
  {
    "status": "cancelled",
    "task_id": "..."
  }
  ```
- **Validations**:
  - Job must be `open` or `funded`
  - If `funded`: blocks cancel while submissions are `judging` (409)
  - Sets pending/judging submissions to `failed`
- **Concurrency**: `with_for_update()` row lock (C2)
- **State transition**: `open|funded` → `cancelled`

---

### 14. POST `/jobs/<task_id>/refund`
- **Handler**: `refund_job()` (server.py:681)
- **Auth**: `buyer_id` must match `job.buyer_id`
- **Request Body**:
  ```json
  {
    "buyer_id": "required (must be job creator)"
  }
  ```
- **Response**: 200
  ```json
  {
    "status": "refunded",
    "task_id": "...",
    "amount": 10.0,
    "refund_tx_hash": "0x..." // only if on-chain refund
  }
  ```
- **Validations**:
  - Job must be `expired` or `cancelled`
  - Idempotency: rejects if `refund_tx_hash` already set (409)
- **Concurrency**: `with_for_update()` row lock + `refund_tx_hash = 'pending'` marker (C1)
- **On-chain**: Sends full amount back to `depositor_address` via `WalletService.refund()`
- **Off-chain**: Sets `refund_tx_hash = 'off-chain'`
- **Service**: `WalletService.refund()`

---

## Internal Functions (not exposed as routes)

| Function | Location | Purpose |
|---|---|---|
| `_run_oracle(app, submission_id)` | server.py:58 | Background oracle thread: guard → 6-step evaluation → verdict → payout |
| `_sanitize_oracle_steps(steps)` | server.py:165 | Strip LLM output from oracle steps for API response |
| `_submission_to_dict(sub)` | server.py:194 | Serialize Submission model to API dict |

## Service Layer Functions

### AgentService (agent_service.py)
| Method | Description |
|---|---|
| `register(agent_id, name, wallet_address)` | Register new agent |
| `get_profile(agent_id)` | Get agent profile dict |
| `update_reputation(agent_id)` | Recalculate completion_rate from submission history |

### JobService (job_service.py)
| Method | Description |
|---|---|
| `check_expiry(job)` | Lazy expiry check — marks funded jobs as expired if past expiry |
| `list_jobs(status, buyer_id, worker_id)` | List jobs with optional filters |
| `get_job(task_id)` | Get single job (with expiry check) |
| `to_dict(job)` | Serialize Job model to API dict |

### OracleGuard (oracle_guard.py)
| Method | Description |
|---|---|
| `programmatic_scan(text)` | Layer A: regex injection pattern detection |
| `llm_scan(text)` | Layer B: LLM-based semantic injection detection |
| `check(text)` | Run both layers sequentially |

### OracleService (oracle_service.py)
| Method | Description |
|---|---|
| `evaluate(title, description, rubric, submission)` | Run Steps 2-6 oracle evaluation |

### WalletService (wallet_service.py)
| Method | Description |
|---|---|
| `is_connected()` | Check if Web3 + ops key configured |
| `get_ops_address()` | Return operations wallet address |
| `verify_deposit(tx_hash, expected_amount)` | Verify USDC deposit tx on-chain (12 confirmations) |
| `send_usdc(to_address, amount)` | Send USDC from ops wallet |
| `payout(worker_address, task_price)` | 80/20 split: worker payout + fee transfer |
| `refund(depositor_address, amount)` | Full refund to depositor |

## Authentication

**No authentication is implemented.** All endpoints accept any caller. Identity is passed as `buyer_id` or `worker_id` in request body/params but is never cryptographically verified. Authorization checks are:
- Fund/cancel/refund: `buyer_id == job.buyer_id`
- Submit: `worker_id in job.participants`
- Claim: `worker_id != job.buyer_id` (self-dealing prevention)
